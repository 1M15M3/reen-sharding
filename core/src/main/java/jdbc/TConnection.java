package jdbc;

import datasource.AudeDataSource;
import jdbc.adapter.UnsupportedConnectionAdapter;
import jdbc.model.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import router.IRouteService;

import javax.sql.DataSource;
import java.sql.*;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by aude on 2016/12/21.
 */
public class TConnection extends UnsupportedConnectionAdapter {

    private final static Logger logger = LoggerFactory.getLogger(TConnection.class);

    private AudeDataSource audeDataSource;

    //已经打开的connection,一个TConnection对应一个真实的数据库只会有一个真实的Connection,为了资源和事务考虑
    private Map<DataSource, Connection> openedConnection = new ConcurrentHashMap<DataSource, Connection>(2);

    // 业务层获取metaData对应的Connection,分表情况下,所有表的schema可能不同,需要通过一个后台来检测不一致
    private Connection connectionForMetaData;

    // 这个TConnection上已经打开的statement
    private Set<TStatement> openedStatement = new HashSet<TStatement>(2);

    // 是否自动提交
    private boolean isAutoCommit = true;//jdbc规范,新连接为true

    // 这个TConnection 是否已经关闭
    private boolean closed;

    // 默认的事务隔离级别
    private int transactionIsolation = TRANSACTION_READ_COMMITTED;

    //事务执行器
    private TExecuter executer;

    public TConnection(IRouteService routeService, AudeDataSource audeDataSource) {
        this.audeDataSource = audeDataSource;
        executer = new TExecuter(routeService, audeDataSource, openedConnection);
    }

    public ResultSetHandler executeSql(StatementCreateCommand createCommand, ExecuteCommand executeCommand, Map<Integer, ParameterCommand> parameterCommand, TStatement stmt) throws SQLException {
        checkClosed();
        return executer.execute(createCommand, executeCommand, parameterCommand, stmt);
    }

    private void checkClosed() {
    }

    @Override
    public Statement createStatement() throws SQLException {
        checkClosed();
        StatementCreateCommand command = new StatementCreateCommand(StatementCreateMethod.createStatement, null);
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return null;
    }

    @Override
    public void setAutoCommit(boolean autoCommit) throws SQLException {

    }

    @Override
    public boolean getAutoCommit() throws SQLException {
        return false;
    }

    @Override
    public void commit() throws SQLException {

    }

    @Override
    public void rollback() throws SQLException {

    }

    @Override
    public void close() throws SQLException {

    }

    @Override
    public boolean isClosed() throws SQLException {
        return false;
    }

    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        return null;
    }

    @Override
    public void setReadOnly(boolean readOnly) throws SQLException {

    }

    @Override
    public boolean isReadOnly() throws SQLException {
        return false;
    }

    @Override
    public void setTransactionIsolation(int level) throws SQLException {

    }

    @Override
    public int getTransactionIsolation() throws SQLException {
        return 0;
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {

    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return null;
    }

    @Override
    public int getHoldability() throws SQLException {
        return 0;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return null;
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return null;
    }

    @Override
    public boolean isValid(int timeout) throws SQLException {
        return false;
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        return null;
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return false;
    }
}
